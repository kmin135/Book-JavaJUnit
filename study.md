# JUnit 학습

* 자바와 JUnit을 활용한 실용주의 단위 테스트 (초판 2019년 6월 30일) 읽고 알아둘 내용만 정리

## 알아둘 정적 import packages

```java
// fail(), assertTrue(boolean), assertThat(actual, matcher)
org.junit.Assert.*;

// 핵심 Matcher
org.hamcrest.CoreMatchers.*;
```

## 단위 테스트의 기본 구조

* Arrange, Act, Assert
* 준비, 실행, 단언

## JUnit 기본

* 각 단위 테스트 (`@Test` 가 붙은 메서드 하나) 는 독립된 컨텍스트에서 실행된다. 각 테스트를 실행할 때마다 인스턴스가 새롭게 생기는 것이다. 
* 각 테스트는 순서가 보장되지 않으며 다른 테스트의 결과에 영향을 받지 않는다.
* 모든 테스트마다 공통적으로 수행할 작업은 `@Before`로 한다. 이는 모든 `@Test` 메서드가 실행될 때마다 한 번씩 실행된다. 역시 2개 이상의 `@Before`가 있다면 순서는 보장되지 않는다. 후작업은 `@After` 를 사용한다.
* 클래스 레벨로 한 번씩만 실행하고 싶은 작업은 `@BeforeClass`, `@AfterClass` 사용.

## 햄크레스트 매처 예제

```java
assertThat(account.balance(), equalTo(100));
assertThat(account.balance(), not(equalTo(100)));
assertThat(accoutn.name(), notNullValue());
assertThat(account.name(), startsWith("John"));
// 리스트와 같은 컬렉션도 가능
assertThat(new String[]{"a","b"}, equalTo(new String[]{"a","b"}));
// is는 인자로 받은 매처를 그대로 리턴한다. 가독성을 높이는데 활용할 수 있다.
assertThat(account.name(), is(equalTo("Bob")));
// 단언에는 별도의 message를 추가할 수 있다. 하지만 코드의 깔끔함과 trade-off
assertThat("account balance is 100", account.balance(), equalTo(50));

/*
* JUnit에 포함된 hamcrest는 부분집합이며
* org.hamcrest.number.IsCloseTo.* 와 같은 매쳐들은 hamcrest-all이 필요하다.
*/
assertThat(2.32 * 3, closeTo(6.96, 0.0005));
```

## 예외 처리

```java
// 1. 애너테이션
@Test(expected=IllegalArugmentException.class)

// 2. try-catch
// catch 구문에서 예외 발생 후 exception에 대한 단언을 하는 경우 등에서 유용

// 3. ExpectedException 규칙
// 1번과 2번 스타일을 겸할 수 있음
@Rule
public ExpectedException thrown = ExpectedException.none();

@Test
public void exceptionRule() {
    thrown.expect(IllegalArugmentException.class);
    thrown.expectMessage("balance only 0");
    account.withdraw(100);
}
```

## 좋은 테스트 작성 가이드

* 개별 메서드를 테스트하기보다 의미있는 동작 단위로 테스트 작성
* 테스트 파일의 물리적인 위치는 소스 디렉토리는 분리하되 프로덕션 코드와 같은 패키지에 위치한다.
* 내부 동작 (private, default, protected 메서드) 에 대한 테스트의 필요성을 느껴 테스트를 작성할 경우 특정 구현에 종속적인 테스트가 되며 이는 작은 수정에도 쉽게 깨지는 테스트가 된다. 또 그런 메서드들은 일반적으로 단일 책임 원칙 (SRP) 를 어기는 설계 문제를 가지고 있을 가능성이 높다. 따라서 별도의 클래스의 public 메서드로 분리할 수 있을지 검토해봐야한다.
* 하나의 테스트는 하나의 목적을 가지는 것이 좋다. 작성의 편의성 때문에 하나의 테스트에 여러 테스트를 포함할수록 테스트의 의미가 추상적이게 되며 테스트가 깨졌을 때 문제를 파악하기도 어렵다.
* 테스트 메서드 이름은 그 자체로 문서화될 정도로 구체적으로 작성하는 것이 좋다. 양식을 정했으면 일관성을 유지하는 것이 중요하다. 아래는 예이다.

```java
// 약 7개 정의 단어로 구성하는 방법
doingSomeOperationGeneratesSomeResult

// when, then
whenDoingSomeBehaviorThenSomeResultOccurs
```

* 공통적인 사전작업이 많고 논리적으로 분리될 수 있다면 별도의 `@Before` 메서드로 분리하자. 순서가 보장되지 않음에 주의.
* 단위 테스트는 빨라야하며 더 느린 통합 테스트는 별도로 다루는 것이 좋다.
* 테스트 대상에서 제외하고 싶을 때는 주석처리하지말고 `@Ignore` 처리한다. 이는 별도로 수치화되기 때문에 까먹지 않게 된다.

## FIRST : 좋은 테스트 조건

* Fast : 테스트는 빨라야하고 느린 메서드 (DB, 외부I/F 등) 는 Mocking한다.
* Isolated : 각 테스트는 환경과 다른 테스트로부터 독립적이어야한다. 단일 책임 원칙 (SRP)를 기억하자.
* Repeatable : 여러번 실행해도 결과가 늘 같아야한다. 예를 들어 시간을 다루는 테스트라면 이에 주의해야한다.
* Self-Validating : 테스트는 스스로 준비 (Arrange)되고 검증 (Assert) 될 수 있어야한다. 테스트 전에 수동으로 준비 작업을 해야하는 등의 절차가 있어서는 안 된다.
* Timely : 작성되는 코드에 대해서는 미루지 않고 테스트코드도 작성해야한다. 미룰 수록 테스트를 작성하는 것은 더 어려워진다. 다만 레거시 코드에 대해 뒤늦게 테스트를 작성하는 것은 투자 대비 효율이 좋지 못할 가능성이 높다.

## Right-BICEP : 무엇을 테스트할 것인가?

* Right : 결과가 올바른가?
  * 코드가 정상적으로 동작한다면 그것을 어떻게 알 수 있는가?
* B : 경계 조건 (boundary conditions)은 맞는가? 외부에 노출되는 API라면 엄격한 보호가 필요하지만 내부적인 API라면 과도한 검사는 줄일 수도 있다.
  * 모호하고 일관성 없는 입력. 예를 들면 특수문자 `"!*\:&@` 가 포함된 파일 이름
  * 잘못된 양식의 데이터. 예를 들어 최상위 도메인이 빠진 이메일 주소 `kmin@google.`
  * 수치적 오류를 발생시키는 계산. 예를 들어 `overflow`, `나누기 0`
  * 비거나 빠진 값. `0, 0.0, "", null` 등
  * 기대값을 훨씬 벗어나는 값. `150세`의 나이 등.
  * 중복이 불가능한 목록에 중복이 있는 경우
  * 정렬이 안 된 컬렉션 혹은 그 반대의 경우
  * 기대한 시간 순서가 맞지 않는 경우. 예를 들어 HTTP 서버가 OPTIONS 메서드의 결과를 POST 메서드보다 늦게 반환하는 경우.
* I : 역 관계(inverse relationship)를 검사할 수 있는가? 논리적인 역 관계를 적용하여 행동을 검사할 수 있다.
  * 제곱근을 구하는 메서드를 만들었다면 제곱근을 제곱했을 때 원래의 수와 동일하거나 한 없이 가까운 수가 나와야한다.
  * 전체 집합에서 배타적인 두 집합을 구했다면 그 합은 원래의 집합과 같아야한다.
* C : 다른 수단을 통해 교차 검사(cross-check)할 수 있는가?
  * 실제 구현에는 쓰이지 못했지만 논리적으로 동일한 또 다른 구현이 있다면 (성능 문제나 너무 복잡하거나 등의 이유로) 이를 통해 교차 검사할 수 있다.
* E : 오류 조건 (error conditions)을 강제로 일어나게 할 수 있는가? 커버리지만 높인다고 좋은 테스트가 아니며 창의력을 발휘해 다양한 오류 상황을 시뮬레이션해야한다.
  * memory 또는 disk full
  * 서버와 클라이언트간의 시간이 다름
  * 네트워크 오류
  * 매우 높거나 낮은 비디오 해상도
* P : 성능 조건 (performance characteristics)은 기준에 부합하는가?
  * 여러번 반복 테스트하여 실행 타이밍에 따른 오차를 최소화해야한다.
  * 성능 테스트는 실행 환경에 따라 결과가 달라지므로 성공 기준을 정하는데 주의를 기울여야한다. 예를 들어 1초이내에 천 번 실행되야한다고 기준을 세웠을 때 내 컴퓨터와 개발서버에서 실행했을 때의 결과가 다를 수 있다.
  * 실행시간이 길어진다면 빠른 단위 테스트와는 분리하는게 좋다.
  * 위의 내용에 나아가서 성능테스트에 중점을 두고 싶다면 JMeter와 같은 전용 도구로 별도로 테스트하는 것도 좋다.

## 경계 조건: CORRECT 를 기억하라

### Conformance (준수)

* 데이터가 특정 양식을 준수하는가를 검사한다.
* 이메일, 전화번호, 계좌번호 등
* ex) 이메일이라면 `name@somedomain` 와 같은 정상 이메일부터 `@`가 없거나 `null` 값이 들어오는 등 다양한 경계조건을 테스트

### Ordering (순서)

* 데이터의 순서가 올바른지 테스트

### Range (범위)

* 데이터의 범위를 테스트
* 기본형 데이터를 그대로 다루기보다 이를 목적에 맞게 캡슐화하는 방법도 검토할 수 있다.
  * ex) 방위 (0~359도)를 나타날 때 int형을 쓰기 보다는 `Bearing` 클래스로 캡슐화하고 이를 테스트할 수 있음
* 범위 조건 테스트가 복잡해진다면 사용자 정의 Matcher 를 검토
  * ex) [ConstrainsSidesTo.java](iloveyouboss_16/test/scratch/ConstrainsSidesTo.java)
* 인덱스 테스트 항목은 아래와 같다
  * 시작과 마지막 인덱스가 같으면 안 됨
  * 시작이 마지막보다 크면 안 됨
  * 인덱스는 음수이면 안 됨
  * 인덱스는 허용된 것보다 크면 안 됨
  * 개수가 실제 항목 개수와 일치해야함

### Reference (참조)

* 범위를 넘어서는 것을 참조하고 있지 않은지
* 외부 의존성은 무엇인지
* 특정 상태에 있는 객체를 의존하고 있는지
  * ex) 자동차의 변속기 기능을 만든다면 `주행 중에 주차로 바꾸는` 파괴적인 요청을 무시해야한다.
* 반드시 존재해야 하는 그 외 다른 조건들

### Existence (존재)

* 주어진 값이 존재하는가?
* null, 0, empty, ...
* 기대하는 파일이 없는 경우, 네트워크 다운, 라이센스 등

### Cardinality(기수)

* 데이터가 몇 개인지에 따른 동작을 테스트해야한다.
* 0-1-n 법칙
  * 0
  * 1
  * n (1보다 많은)
* 테스트 코드는 0, 1, n의 경계 조건에 집중하고 n은 비즈니스 요구사항에 따라 바뀔 수 있다.
* 아래는 예제
  * 목록에 항목이 0개일 때 보고서 출력하기
  * 목록에 항목이 1개일 때 보고서 출력하기
  * 목록에 항목이 0개일 때 1개 항목 추가하기
  * 목록에 항목이 1개일 때 1개 항목 추가하기
  * 목록에 항목이 10개 미만일 때 1개 항목 추가하기
  * 목록에 항목이 10개일 때 1개 항목 추가하기

### Time (시간)

* 상대적 시간 (시간 순서)
  * 메서드의 호출 순서 : logout전에 먼저 login을 해야한다 등. 순서가 바뀌면 어떻게 되는가? 일부 과정이 생략되면 어떻게 되는가? 데이터의 순서도 중요하지만 메서드의 순서도 중요하다.
  * 타임아웃 : 몇 초까지 기다릴 수 있는가? 무한대기가 발생하지는 않는가?
* 절대적 시간 (측정된 시간)
* 동시성 문제
  * 같은 객체에 동시에 여러 스레드가 접근하는 경우
  * 어떤 데이터나 메서드에 동기화 처리를 해야하는가?
  * 파일, 네트워크와 같은 외적인 접근 처리

## 깔끔한 코드로 리팩토링하기

* 리팩토링은 기존 기능을 유지하면서 코드 구조를 정리하는 것
* 낮은 중복성과 높은 명확성을 달성하기

### 리팩토링 가이드

* 논리적인 단위로 메서드 추출
* 과한 리팩토링에 대한 고민
  * ex) 변경 전에는 컬렉션을 1번만 iterate 했던 코드를 리팩토링 후 논리적인 메서드로 분리하면서 3번 중복 iterate가 발생한다면 성능에 대한 고민이 들 수 있다. 하지만 정말로 성능이 문제가 되는 경우가 아니라면 깔끔한 설계를 유지하는 쪽이 유지보수 측면에서 이득이다.
  * 이에 대한 설득이 필요하다면 변경 전과 후의 성능 테스트를 통해 근거를 확보할 수 있다.

## 더 큰 설계 문제

* SOLID와 같은 큰 설계 측면에서 리팩토링을 수행한다.
* SOLID
  * SRP (단일 책임 원칙) : 클래스는 한 가지 목적만을 가진다.
  * OCP (개방 폐쇄 원칙) : 클래스는 확장에 열려 있고 변경에는 닫혀있어야 한다.
  * LSP (리스코프 치환 원칙) : 하위 타입을 반드시 상위 타입을 대체할 수 있어야한다.
  * ISP (인터페이스 분리 원칙) : 클라이언트는 필요하지 않은 메서드에 의존하면 안 된다. 커다란 인터페이스를 다수의 작은 인터페이스로 분할하자.
  * DIP (의존성 역전 원칙) : 고수준 모듈은 저수준 모듈을 의존해서는 안 된다. 둘 다 추상클래스에 의존해야한다. 추상 클래스는 구체 클래스에 의존해서는 안 된다. 구체 클래스는 추상 클래스에 의존해야 한다.
* 명령-질의 분리 (command-query separation)
  * 어떤 메서드는 명령을 실행 (부작용을 생성하는 어떤 작업을 수행) 하거나 질의에 응답 (어떤 값을 반환) 할 수 있으며 두 작업을 모두 하면 안 된다.
  * ex) 어떤 상태값을 얻기 위한 메서드에 상관없는 변수의 값을 변경하는 (부작용) 코드가 있으면 안 된다.
  * 이를 위반하는 대표적인 API는 java.util.Iterator 인터페이스. (생각없이 next를 호출하면 안 된다.)

## 단위 테스트의 비용

* 코드가 변경됨에 따라 기존의 테스트도 함께 수정해야하며 이것이 단위 테스트를 소유하는 비용.
* 변경에 따라 많은 테스트가 깨진다면 많은 설계 문제를 내포하고 있다는 부정적인 설계 지표로 볼 수 있다.
* 시스템 설계 및 코드 품질이 낮을수록 단위 테스트의 유지 보수 비용은 증가한다.

### 단위 테스트 설계 Tip

* 애플리케이션과 마찬가지로 단위 테스트도 중복을 최소화등의 설계 문제를 검토하자.
* 테스트 초기화로직 (Arrange)이나 중복된 로직은 별도의 메서드로 분리하자.
* 단위 테스트의 설정에 많은 코드가 필요하다면 시스템 설계가 잘못되었다는 신호다. 또한 이런 테스트는 코드변경에 따라 점점 더 테스트하기 어려워진다.
* private 메서드를 (구현 세부 사항) 테스트하려는 충동은 클래스가 너무 커졌다는 신호일 수 있다. 이 때는 private 메서드를 새로운 클래스로 옮기고 public 으로 만드는게 좋다.

## MOCK 객체 사용

* 외부 API에 종속적인 코드들과 같이 통제할 수 없거나 DB연결과 같이 느린 작업은 Stub이나 Mock으로 대체할 수 있다.
* [TestDouble](https://martinfowler.com/bliki/TestDouble.html)

### Stub

* Stub : 테스트 용도로 하드 코딩한 값을 반환하는 구현체
  * [Stub 예제](iloveyouboss_mock-2/test/iloveyouboss/AddressRetrieverTest.java)

### Mock

* Mock : 의도적으로 흉내 낸 동작을 제공하고 수신한 인자가 모두 정상인지 여부를 검증하는 테스트 구조물
  * [Mock 예제](iloveyouboss_mock-4/test/iloveyouboss/AddressRetrieverTest.java)
  * [Mockito DI](iloveyouboss_mock-5/test/iloveyouboss/AddressRetrieverTest.java)
* 이상적으로는 `when...then` 구조로 1줄로 동작하고 1줄로 단언한다.
* Mock을 사용할 때의 검토 사항
  1. 프로덕션 코드의 동작을 올바르게 묘사하는가?
  2. 프로덕션 코드는 예상치 못한 형식으로 반환하는가?
  3. 프로덕션 코드는 예외를 던지는가? null을 반환하는가?
* Mock은 결국 프로덕션 코드에 대한 단위 테스트의 구멍이 될 수 있다. 통합 테스트를 통해 이 구멍을 막아야한다.

## 테스트 리팩토링

### 테스트 냄새: 불필요한 테스트 코드

* 테스트가 예외를 기대하지 않는 다면 throws 처리해라
* 단언이 하는일이 중복된다면 하나로 줄이는걸 검토해라

### 테스트 냄새: 추상화 누락

* 클라이언트가 시스템과 어떻게 상호 작용하는지 추상화해라
* 한 눈에 들어오지 않는 n줄의 복잡한 단언을 1줄의 사용자 단언으로 리팩토링할 수 있다.
  * [사용자 단언 예제 (변경 전)](iloveyouboss_test-02/test/util/SearchTest.java)
  * [사용자 단언 예제 (변경 후)](iloveyouboss_test-03/test/util/SearchTest.java)

### 테스트 냄새: 부적절한 정보

* 의미가 불분명한 매직 리터럴 (`"1"`, `http://bit.ly/dlfek125`) 을 지양하고 적절한 변수명을 가지는 상수등을 도입하여 테스트의 가독성을 높이자

### 테스트 냄새: 부푼 생성

* 복잡한 생성 로직을 별도 메서드로 숨기자
  * [부푼 생성 예제 (변경 전)](iloveyouboss_test-04/test/util/SearchTest.java)
  * [부푼 생성 예제 (변경 후)](iloveyouboss_test-05/test/util/SearchTest.java)

### 테스트 냄새: 다수의 단언

* 테스트는 단언 하나로 정리되는 것이 좋다. 테스트 이름도 더 깔끔해진다.
* 여러 개의 단언이 있다면 목적이 다른 여러 개의 테스트를 포함하고 있을 가능성이 높다. 이렇게 되면 테스트의 이름도 불분명해지기 쉽다.

### 테스트 냄새: 테스트와 무관한 세부 사항들

* 로깅 설정, 스트림의 닫기 작업 등 테스트 시나리오와는 관계 없는 기술적 세부 사항들은 `@Before`, `@After` 로 정리하자.
* 이 때 비즈니스적으로 의미가 있는 내용은 공통되더라도 각 테스트에 남겨두는게 가독성에 좋다.

### 테스트 냄새: 잘못된 조직

* AAA의 구조를 알기 쉽게 한다. 각 부분을 개행으로 구분하면 좋다.

### 테스트 냄새 : 암시적 의미

* 테스트의 가장 중요한 질문 : "왜 그러한 결과를 기대하는가?"
* Arrange와 Assert를 상호 연관 지을 수 있어야한다.
* 의미 있는 상수, 좋은 변수 이름 등 센스가 필요한 영역
* [암시적 의미 예제](iloveyouboss_test-9/test/util/SearchTest.java)

### 기타

* 테스트코드의 설계가 좋을수록 유지보수 비용은 낮아지고 테스트 내용을 이해하는데 필요한 노력은 감소한다.

## 테스트 주도 개발

* TDD 사이클
  1. 실패하는 테스트 코드 작성 (테스트)
  2. 테스트 통과시키기 (코드)
  3. 이전 두 단계에서 추가되거나 변경된 코드 개선하기 (리팩토링)
* 각 사이클은 실패하는 테스트에 대해 그 테스트를 통과할 수 있는 가장 작은 수정을 반복하며 진행한다.
* 핵심은 테스트가 나타내는 명세를 정확히 코딩하는 것.
* 테스트가 많아진다면 논리적인 단위로 클래스로 쪼개는 것도 좋다.

```java
// before
class ProfileTest {
    testSome1_a
    testSome1_b
    testSome2_a
    testSome2_b
}
// after
class Profile_Some1Test { ... }
class Profile_Some2Test { ... }
```
* 각 사이클을 작게 유지하는 것이 좋다. 약 10분 정도로 제한해보고 그 동안 테스트를 통과하지 못한다면 작업하던 코드는 버리고 좀 더 작은 단위로 도전해볼 수 있다.
  * 각 사이클은 테스트를 가설로 한 실험이다. 실패한다면 빠르게 버리고 다른 관점에서 다시 시작하면 (가정의 범위를 축소하는 등) 무엇이 잘못되었는지 파악하는데 도움이 된다.


### TDD 장점

* TDD의 테스트는 시스템이 무엇을 하는지 문서화 역할도 함.
* 추측에 근거한 개발을 피하게 됨
* 리팩토링이 개발 사이클에서 자연스럽게 이루어짐

## 까다로운 테스트

* 어려운 시나리오의 테스트에서는 다음 전략을 따르자.
  1. 관심사를 분리하자. 애플리케이션 로직은 스레드, DB 등의 다른 의존성과 분리하자. 의존적인 코드를 독립시켜 코드베이스에서 만연하지 않도록 하자.
  2. 느리거나 휘발적인 코드는 mock을 사용하여 단위 테스트의 의존성을 끊자
  3. 필요한 경우 통합 테스트를 작성하되, 단순하고 집중적으로 만들자.

### 멀티스레드 코드 테스트

* 멀티스레드는 단위 테스트가 아닌 통합 테스트의 영역에 가깝다.
* 어플리케이션 로직과 스레드와 관련된 로직을 분리하여 테스트
* [멀티스레드 예제 (변경 전)](iloveyouboss_thread-1/src/iloveyouboss/ProfileMatcher.java)
* [멀티스레드 예제 (변경 후)](iloveyouboss_thread-4/src/iloveyouboss/ProfileMatcher.java)

### 데이터베이스 테스트

* DAO 클래스 자체를 단위 테스트하는 건 큰 의미가 없다.
  * 모두 Stub 또는 Mock 으로 테스트해야하니 노력도 많이 들고 증명하는 의미도 별로 없다.
* 따라서 실제 동작하는 DB와 연결되는 통합테스트가 더 적절하다.

#### 데이터 의존성을 없애는 방법

* 동작하는 DB에 이미 데이터가 있거나 추후 누구나 변경할 수 있다면 데이터는 쉽게 깨질  것이므로 이런 의존성을 없애기 위한 방법이 필요
  1. 테스트용 로컬 DB사용 : H2같은걸 사용해볼 수 있지만 프로덕션에서 사용하는 DBMS와의 차이에서 올 수 있는 미묘한 차이가 문제를 발생시킬 수 있다.
  2. 트랜잭션 사용 : 테스트마다 트랜잭션을 초기화하고, 테스트가 끝나면 롤백한다. (`@Before`, `@After` 활용)
  3. 클린 룸 데이터베이스 테스트 : 모든 테스트의 실행 전후에 데이터베이스를 비운다. [클린 룸 예제](iloveyouboss_16-branch-persistence-redesign/test/iloveyouboss/controller/QuestionControllerTest.java)
* DAO를 통합테스트한 뒤 이를 사용하는 Service단에서는 DAO를 mock 처리하여 테스트한다.
  * [DAO mock 처리 예제](iloveyouboss_16-branch-persistence-3/test/iloveyouboss/domain/StatCompilerTest.java)

### 통합테스트

* 통합 테스트는 필수지만 설계하고 유지 보수하기가  어렵다.
* 단위 테스트에서 검증하는 로직을 최대화하여 통합 테스트의 개수와 복잡도를 최소하하는 것이 중요하다.

## 실제 프로젝트에서 테스트

* 책의 테스트에 대한 권장사항에 모두가 동의하지 않을 것이다. 테스트가 필요없다고 주장하는 사람, 필요하다고 생각한 부분에 대해서만 테스트를 작성하는 사람, TDD를 도입하고자 하는 사람, 통합 테스트를 선호하는 사람 등이 있을 것이다.
* 프로젝트에 도입할 때는 단위 테스트에 대한 표준을 만들고 이를 지키도록 합의를 하는 것이 중요하다.

### 단위 테스트 표준 만들기

* 작게 시작하는 게 좋고 다음 두 질문에 대해 생각해보자
  1. 개발자들은 어떤 것이 모든 사람의 시간을 낭비하게 만든다고 느끼는가?
  2. 모두가 빠르게 동의할 수 있는 단순한 표준은 무엇인가?
* 팀원들과 토론하고 가능한 자주 표준에 대해 재검토하고 수정하자
* 기본적인 표준화 목록
  * 코드를 체크인하기 전 어떤 테스트를 실행할지의 여부
  * 테스트 클래스와 메서드의 네이밍
  * hamcrest 또는 전통적인 단언 사용 여부
  * AAA 사용 여부
  * 선호하는 Mock 도구
  * 체크인 테스트를 실행할 떄 콘솔에 출력을 허용할지 여부
  * 단위 테스트 스위트에서 느린 테스트를 식별하고 막을 방법
* 표준을 준수하도록 코드 리뷰를 하자
  * Github의 Pull Request 와 같은 도구를 활용
  * Intellij의 UpSource와 같이 IDE에 통합되는 플러그인을 활용하는 것도 좋음
* 페어 프로그래밍
  * Pull Request와 같은 사후 리뷰 방식의 맹점은 대상 코드에 대한 이해도 만큼만 리뷰를 할 수 있다는 점
  * 페어 프로그래밍은 그 코드를 아주 잘 이해하는 2명의 상시 코드리뷰가 되는 장점이 있다. 물론 실제 환경에 적용하는 것은 여러 현실적인 어려움이 있다.
* 지속적인 통합 (CI)
  * 내 컴퓨터에서 되는게 중요한게 아니라 통합 서버에서 정상 동작하는게 중요하다.
  * CI는 현대 개발 팀의 최소 요건이다.
* 코드 커버리지
  * 절대적인 수치는 없지만 약 70% 이상을 권장한다.
  * TDD는 그 특성상 90% 이상이 자연스럽게 달성된다.
  * 그렇다고 수치에만 집중하면 가치가 없는 테스트만 양산될 수 있으니 주의 필요.
  * 수치 자체는 중요하지 않고 코드 커버리지의 추세가 중요하다.
    * 아래로 내려가면 안 된다!

## 도구

* Infinitest : 백그라운드에서 테스트를 항상 수행
* Jenkins : CI과정에 테스트 포함시키기
* Mockito : Mocking 라이브러리

## 좋은 링크

* [마틴파울러의 테스팅에 관한 글들](https://martinfowler.com/tags/testing.html)

## 소감

* 예제 소스가 좀 보기 어려웠다. 더 심플한 도메인이었으면 좋았을 듯.
* 어디까지나 단위 테스트 책. 통합테스트는 일부 언급되어있지만 책의 영역이 아니므로 별도 학습 필요.
* 책 보다 생각난건데 유명 오픈소스들의 테스트 코드를 보는 것도 도움이 될 것 같다.